<?php
/**
 * Test Temizleme Yardƒ±mcƒ± Sƒ±nƒ±fƒ±
 * 
 * Test ortamƒ±nda olu≈üturulan gereksiz dosyalarƒ± otomatik olarak temizler.
 * G√ºvenlik i√ßin sadece Tests/ klas√∂r√º altƒ±ndaki dosyalarƒ± i≈üler.
 * 
 * @author GitHub Copilot
 * @date 2025-06-24
 */

// Test framework'√ºn√º y√ºkle
include_once __DIR__ . '/../index.php';

class TestCleaner
{
    /**
     * @var string Tests klas√∂r√ºn√ºn tam yolu
     */
    private static $testsPath;
      /**
     * @var array Silinebilir dosya uzantƒ±larƒ±
     */
    private static $allowedExtensions = [
        'php', 'txt', 'log', 'json', 'xml', 'csv', 'html', 'md', 'css', 'js'
    ];
    
    /**
     * @var array Korunacak dosyalar (silinmeyecek)
     */
    private static $protectedFiles = [
        'index.php',
        'README.md',
        'TestModel/TestAssert.php',
        'TestModel/TestDataGenerator.php',
        'TestModel/TestLogger.php',
        'TestModel/TestRunner.php',
        'TestModel/TestValidator.php',
        'example_test.php'
    ];
    
    /**
     * Sƒ±nƒ±f ba≈ülatma
     */
    public static function init()
    {
        self::$testsPath = realpath(__DIR__ . '/../');
        TestLogger::info('TestCleaner ba≈ülatƒ±ldƒ±: ' . self::$testsPath);
    }
    
    /**
     * Belirtilen dosyalarƒ± siler
     * 
     * @param array $files Silinecek dosyalar (Tests klas√∂r√ºne g√∂re relative path)
     * @param bool $dryRun Sadece kontrol et, ger√ßekten silme (default: false)
     * @return array Sonu√ß raporu
     */
    public static function cleanFiles($files, $dryRun = false)
    {
        self::init();
        
        $results = [
            'deleted' => [],
            'skipped' => [],
            'errors' => [],
            'protected' => []
        ];
        
        TestLogger::info('Dosya temizleme ba≈ülatƒ±ldƒ±' . ($dryRun ? ' (DRY RUN)' : ''));
        TestLogger::info('Toplam dosya sayƒ±sƒ±: ' . count($files));
        
        foreach ($files as $file) {
            $result = self::deleteFile($file, $dryRun);
            $results[$result['status']][] = $result;
        }
        
        self::printSummary($results, $dryRun);
        return $results;
    }
    
    /**
     * Tek dosya silme i≈ülemi
     * 
     * @param string $file Dosya yolu (Tests klas√∂r√ºne g√∂re relative)
     * @param bool $dryRun Sadece kontrol et
     * @return array Dosya i≈ülem sonucu
     */
    private static function deleteFile($file, $dryRun = false)
    {
        // Dosya yolunu normalle≈ütir
        $file = str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $file);
        $fullPath = self::$testsPath . DIRECTORY_SEPARATOR . $file;
        
        // G√ºvenlik kontrol√º: Tests klas√∂r√º dƒ±≈üƒ±na √ßƒ±kma
        if (!self::isInTestsFolder($fullPath)) {
            TestLogger::error("G√ºvenlik ihlali: $file Tests klas√∂r√º dƒ±≈üƒ±nda");
            return [
                'file' => $file,
                'status' => 'errors',
                'message' => 'Tests klas√∂r√º dƒ±≈üƒ±nda'
            ];
        }
        
        // Dosya mevcut mu?
        if (!file_exists($fullPath)) {
            TestLogger::warning("Dosya bulunamadƒ±: $file");
            return [
                'file' => $file,
                'status' => 'skipped',
                'message' => 'Dosya bulunamadƒ±'
            ];
        }
        
        // Korumalƒ± dosya mƒ±?
        $filename = basename($file);
        if (in_array($filename, self::$protectedFiles)) {
            TestLogger::warning("Korumalƒ± dosya: $file");
            return [
                'file' => $file,
                'status' => 'protected',
                'message' => 'Korumalƒ± dosya'
            ];
        }
        
        // Dosya uzantƒ±sƒ± uygun mu?
        $extension = pathinfo($file, PATHINFO_EXTENSION);
        if (!in_array($extension, self::$allowedExtensions)) {
            TestLogger::warning("ƒ∞zin verilmeyen uzantƒ±: $file ($extension)");
            return [
                'file' => $file,
                'status' => 'skipped',
                'message' => "ƒ∞zin verilmeyen uzantƒ±: $extension"
            ];
        }
        
        // Dosyayƒ± sil (veya dry run)
        if ($dryRun) {
            TestLogger::info("DRY RUN: Silinecek -> $file");
            return [
                'file' => $file,
                'status' => 'deleted',
                'message' => 'DRY RUN - Silinebilir'
            ];
        }
        
        try {
            if (unlink($fullPath)) {
                TestLogger::success("Silindi: $file");
                return [
                    'file' => $file,
                    'status' => 'deleted',
                    'message' => 'Ba≈üarƒ±yla silindi'
                ];
            } else {
                TestLogger::error("Silinemedi: $file");
                return [
                    'file' => $file,
                    'status' => 'errors',
                    'message' => 'Dosya silinemedi'
                ];
            }
        } catch (Exception $e) {
            TestLogger::error("Hata: $file - " . $e->getMessage());
            return [
                'file' => $file,
                'status' => 'errors',
                'message' => $e->getMessage()
            ];
        }
    }
    
    /**
     * Dosyanƒ±n Tests klas√∂r√º i√ßinde olup olmadƒ±ƒüƒ±nƒ± kontrol eder
     * 
     * @param string $fullPath Tam dosya yolu
     * @return bool
     */
    private static function isInTestsFolder($fullPath)
    {
        $realPath = realpath(dirname($fullPath));
        return $realPath !== false && strpos($realPath, self::$testsPath) === 0;
    }
    
    /**
     * Temizleme √∂zeti yazdƒ±r
     * 
     * @param array $results Sonu√ßlar
     * @param bool $dryRun Dry run modu
     */
    private static function printSummary($results, $dryRun)
    {
        echo "\n" . str_repeat("=", 60) . "\n";
        echo "üìã TEST DOSYA TEMƒ∞ZLEME √ñZETƒ∞" . ($dryRun ? " (DRY RUN)" : "") . "\n";
        echo str_repeat("=", 60) . "\n";
        
        echo "‚úÖ Silinen dosyalar: " . count($results['deleted']) . "\n";
        foreach ($results['deleted'] as $item) {
            echo "   - " . $item['file'] . "\n";
        }
        
        if (count($results['protected']) > 0) {
            echo "\nüõ°Ô∏è  Korumalƒ± dosyalar: " . count($results['protected']) . "\n";
            foreach ($results['protected'] as $item) {
                echo "   - " . $item['file'] . "\n";
            }
        }
        
        if (count($results['skipped']) > 0) {
            echo "\n‚è≠Ô∏è  Atlanan dosyalar: " . count($results['skipped']) . "\n";
            foreach ($results['skipped'] as $item) {
                echo "   - " . $item['file'] . " (" . $item['message'] . ")\n";
            }
        }
        
        if (count($results['errors']) > 0) {
            echo "\n‚ùå Hatalƒ± dosyalar: " . count($results['errors']) . "\n";
            foreach ($results['errors'] as $item) {
                echo "   - " . $item['file'] . " (" . $item['message'] . ")\n";
            }
        }
        
        echo "\n" . str_repeat("=", 60) . "\n";
        TestLogger::info('TestCleaner √∂zet tamamlandƒ±');
    }
    
    /**
     * Belirtilen klas√∂rdeki t√ºm dosyalarƒ± listeler
     * 
     * @param string $folder Tests klas√∂r√ºne g√∂re relative path
     * @param array $extensions Filtrelenecek uzantƒ±lar (bo≈üsa t√ºm√º)
     * @return array Dosya listesi
     */
    public static function listFiles($folder, $extensions = [])
    {
        self::init();
        
        $folder = str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $folder);
        $fullPath = self::$testsPath . DIRECTORY_SEPARATOR . $folder;
        
        if (!is_dir($fullPath)) {
            TestLogger::error("Klas√∂r bulunamadƒ±: $folder");
            return [];
        }
        
        $files = [];
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($fullPath)
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $relativePath = str_replace(self::$testsPath . DIRECTORY_SEPARATOR, '', $file->getPathname());
                
                // Uzantƒ± filtresi
                if (!empty($extensions)) {
                    $extension = pathinfo($file->getFilename(), PATHINFO_EXTENSION);
                    if (!in_array($extension, $extensions)) {
                        continue;
                    }
                }
                
                $files[] = $relativePath;
            }
        }
        
        return $files;
    }
    
    /**
     * Ge√ßici dosyalarƒ± temizle (Temp/ klas√∂r√º)
     * 
     * @param bool $dryRun Sadece kontrol et
     * @return array Sonu√ß raporu
     */
    public static function cleanTempFiles($dryRun = false)
    {
        $tempFiles = self::listFiles('Temp', ['php', 'txt', 'log', 'json']);
        
        if (empty($tempFiles)) {
            TestLogger::info('Temp klas√∂r√ºnde silinecek dosya yok');
            return ['deleted' => [], 'skipped' => [], 'errors' => [], 'protected' => []];
        }
        
        TestLogger::info('Temp klas√∂r√º temizleniyor...');
        return self::cleanFiles($tempFiles, $dryRun);
    }
    
    /**
     * Log dosyalarƒ±nƒ± temizle (30 g√ºnden eski)
     * 
     * @param int $daysOld Ka√ß g√ºnden eski dosyalar silinsin
     * @param bool $dryRun Sadece kontrol et
     * @return array Sonu√ß raporu
     */
    public static function cleanOldLogs($daysOld = 30, $dryRun = false)
    {
        $logFiles = self::listFiles('Logs', ['log']);
        $oldFiles = [];
        
        $cutoffTime = time() - ($daysOld * 24 * 60 * 60);
        
        foreach ($logFiles as $file) {
            $fullPath = self::$testsPath . DIRECTORY_SEPARATOR . $file;
            if (filemtime($fullPath) < $cutoffTime) {
                $oldFiles[] = $file;
            }
        }
        
        if (empty($oldFiles)) {
            TestLogger::info("$daysOld g√ºnden eski log dosyasƒ± yok");
            return ['deleted' => [], 'skipped' => [], 'errors' => [], 'protected' => []];
        }
        
        TestLogger::info("$daysOld g√ºnden eski log dosyalarƒ± temizleniyor...");
        return self::cleanFiles($oldFiles, $dryRun);
    }
    
    /**
     * T√ºm test mod√ºllerindeki ge√ßici dosyalarƒ± temizle
     * 
     * @param bool $dryRun Sadece kontrol et
     * @return array Toplam sonu√ß raporu
     */
    public static function cleanAllTempFiles($dryRun = false)
    {
        self::init();
        
        TestLogger::info('T√ºm mod√ºllerdeki ge√ßici dosyalar temizleniyor...');
        
        $allResults = [
            'deleted' => [],
            'skipped' => [],
            'errors' => [],
            'protected' => []
        ];
        
        // Test mod√ºllerindeki ge√ßici dosya pattern'leri
        $tempPatterns = ['temp_', 'debug_', 'test_', 'old_', 'sample_'];
        $modules = ['Orders', 'Products', 'Members', 'Carts', 'Banners', 'Categorys', 'System'];
        
        // Her mod√ºlde ge√ßici dosyalarƒ± bul
        foreach ($modules as $module) {
            if (is_dir(self::$testsPath . DIRECTORY_SEPARATOR . $module)) {
                $moduleFiles = self::listFiles($module);
                $tempFiles = array_filter($moduleFiles, function($file) use ($tempPatterns) {
                    $filename = basename($file);
                    foreach ($tempPatterns as $pattern) {
                        if (strpos($filename, $pattern) === 0) {
                            return true;
                        }
                    }
                    return false;
                });
                
                if (!empty($tempFiles)) {
                    TestLogger::info("$module mod√ºl√ºnde " . count($tempFiles) . " ge√ßici dosya bulundu");
                    $moduleResults = self::cleanFiles($tempFiles, $dryRun);
                    
                    // Sonu√ßlarƒ± birle≈ütir
                    foreach ($moduleResults as $status => $items) {
                        $allResults[$status] = array_merge($allResults[$status], $items);
                    }
                }
            }
        }
        
        // Temp klas√∂r√ºn√º de temizle
        $tempResults = self::cleanTempFiles($dryRun);
        foreach ($tempResults as $status => $items) {
            $allResults[$status] = array_merge($allResults[$status], $items);
        }
        
        TestLogger::info('T√ºm mod√ºl temizleme tamamlandƒ±');
        return $allResults;
    }
}

// Komut satƒ±rƒ±ndan √ßalƒ±≈ütƒ±rƒ±lƒ±yorsa
if (isset($argv) && basename(__FILE__) == basename($argv[0])) {
    echo "üßπ Test Dosya Temizleyici\n";
    echo "========================\n\n";
    
    if (isset($argv[1])) {
        switch ($argv[1]) {
            case 'temp':
                TestCleaner::cleanTempFiles();
                break;
                
            case 'logs':
                $days = isset($argv[2]) ? (int)$argv[2] : 30;
                TestCleaner::cleanOldLogs($days);
                break;
                
            case 'dry-run':
                echo "üîç DRY RUN - Temp klas√∂r√º kontrol√º:\n";
                TestCleaner::cleanTempFiles(true);
                break;
                  case 'all-temp':
                TestCleaner::cleanAllTempFiles();
                break;
                
            case 'dry-all':
                echo "üîç DRY RUN - T√ºm mod√ºller kontrol√º:\n";
                TestCleaner::cleanAllTempFiles(true);
                break;
                  default:
                echo "Kullanƒ±m:\n";
                echo "  php TestCleaner.php temp          # Temp dosyalarƒ±nƒ± sil\n";
                echo "  php TestCleaner.php logs [days]   # Eski log dosyalarƒ±nƒ± sil\n";
                echo "  php TestCleaner.php all-temp      # T√ºm mod√ºllerdeki ge√ßici dosyalarƒ± sil\n";
                echo "  php TestCleaner.php dry-run       # Sadece temp kontrol√º\n";
                echo "  php TestCleaner.php dry-all       # T√ºm mod√ºller kontrol√º\n";
        }
    } else {
        echo "Kullanƒ±m:\n";
        echo "  php TestCleaner.php temp          # Temp dosyalarƒ±nƒ± sil\n";
        echo "  php TestCleaner.php logs [days]   # Eski log dosyalarƒ±nƒ± sil\n";
        echo "  php TestCleaner.php all-temp      # T√ºm mod√ºllerdeki ge√ßici dosyalarƒ± sil\n";
        echo "  php TestCleaner.php dry-run       # Sadece temp kontrol√º\n";
        echo "  php TestCleaner.php dry-all       # T√ºm mod√ºller kontrol√º\n";
    }
}
